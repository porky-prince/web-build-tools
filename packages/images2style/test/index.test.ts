import os from 'os';
import path from 'path';
import fs from 'fs-extra';
import { images2style } from '../src';
import { isSafeFilename } from 'web-build-utils';

// Partially mock utils to control isSafeFilename while keeping real toPercent.
jest.mock('web-build-utils', () => {
  const actual = jest.requireActual('web-build-utils');
  return {
    ...actual,
    isSafeFilename: jest.fn(() => true),
  };
});

const mockedIsSafeFilename = isSafeFilename as unknown as jest.Mock;

// Track temp directories for cleanup after each test.
const tempDirs: string[] = [];

// Create a unique temp directory per test case.
async function makeTempDir() {
  const dir = await fs.mkdtemp(path.join(os.tmpdir(), 'images2style-'));
  tempDirs.push(dir);
  return dir;
}

// Standardize fixture layout for predictable className and imagePath.
async function makeFixtureDirs() {
  const tempDir = await makeTempDir();
  const srcDir = path.join(tempDir, 'assets');
  const destFile = path.join(tempDir, 'out', 'styles.css');
  return { tempDir, srcDir, destFile };
}

// Helper to write placeholder files (image contents are not read).
async function writeFile(filePath: string, contents: Buffer | string = 'data') {
  await fs.outputFile(filePath, contents);
}

// Helper to write atlas JSON fixtures.
async function writeJson(filePath: string, contents: unknown) {
  await fs.outputJson(filePath, contents);
}

beforeEach(() => {
  mockedIsSafeFilename.mockReturnValue(true);
});

afterEach(async () => {
  await Promise.all(tempDirs.splice(0).map((dir) => fs.remove(dir)));
  jest.clearAllMocks();
});

describe('images2style', () => {
  test('throws when src has an extension', () => {
    expect(() =>
      images2style({
        src: 'icons.png',
        dest: 'out.css',
      })
    ).toThrow('The options.src must be a directory.');
  });

  test('throws when dest has no extension', () => {
    expect(() =>
      images2style({
        src: 'assets',
        dest: 'out',
      })
    ).toThrow('The options.dest must be a file.');
  });

  test('generates css for supported images and includes base template', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();

    await writeFile(path.join(srcDir, 'logo.png'), Buffer.from('png'));
    await writeFile(path.join(srcDir, 'banner.jpg'), Buffer.from('jpg'));
    await writeFile(path.join(srcDir, 'readme.txt'), 'hello');

    await images2style({
      src: srcDir,
      dest: destFile,
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(output).toContain('auto generated by images2style');
    expect(output).toContain('.bg-full');
    expect(output).toContain('.assets-logo-png');
    expect(output).toContain('.assets-banner-jpg');
    expect(output).not.toContain('readme');
  });

  test('skips entries based on include, exclude, and isSafeFilename', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();

    await writeFile(path.join(srcDir, 'keep.png'), Buffer.from('png'));
    await writeFile(path.join(srcDir, 'skip.png'), Buffer.from('png'));
    await writeFile(path.join(srcDir, 'unsafe.png'), Buffer.from('png'));
    await writeFile(
      path.join(srcDir, 'blocked', 'inside.png'),
      Buffer.from('png')
    );

    mockedIsSafeFilename.mockImplementation((value: string) => {
      return !value.includes('unsafe.png');
    });

    await images2style({
      src: srcDir,
      dest: destFile,
      include: (info) => info.name !== 'skip',
      exclude: (info) => info.name === 'blocked',
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(output).toContain('.assets-keep-png');
    expect(output).not.toContain('.assets-skip-png');
    expect(output).not.toContain('.assets-unsafe-png');
    expect(output).not.toContain('.assets-blocked-inside-png');
  });

  test('applies transform to image style output', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();
    const transform = jest.fn((content: string) => {
      return `${content}\n/* transformed */`;
    });

    await writeFile(path.join(srcDir, 'logo.png'), Buffer.from('png'));

    await images2style({
      src: srcDir,
      dest: destFile,
      transform,
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(transform).toHaveBeenCalledTimes(1);
    expect(transform.mock.calls[0][0]).toContain('.assets-logo-png');
    expect(output).toContain('/* transformed */');
  });

  test('generate atlas rules with percent fallback', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();

    // Single Frame
    await writeFile(
      path.join(srcDir, 'sprites', 'sheet.png'),
      Buffer.from('png')
    );
    await writeJson(path.join(srcDir, 'sprites', 'sheet.json'), {
      meta: { size: { w: 2, h: 2 } },
      frames: {
        frame1: { frame: { x: 0, y: 0, w: 2, h: 2 } },
      },
    });

    // Multiple Frames
    await writeFile(
      path.join(srcDir, 'sprites', 'sheets.png'),
      Buffer.from('png')
    );
    await writeJson(path.join(srcDir, 'sprites', 'sheets.json'), {
      frames: {
        'avatar-bg-0': {
          frame: {
            x: 0,
            y: 0,
            w: 218,
            h: 280,
          },
        },
        'avatar-bg-1': {
          frame: {
            x: 220,
            y: 0,
            w: 218,
            h: 248,
          },
        },
        'avatar-bg-2': {
          frame: {
            x: 440,
            y: 0,
            w: 218,
            h: 248,
          },
        },
        fire: {
          frame: {
            x: 440,
            y: 250,
            w: 28,
            h: 28,
          },
        },
        notice: {
          frame: {
            x: 0,
            y: 282,
            w: 32,
            h: 32,
          },
        },
      },
      meta: {
        app: 'spritesheet-templates',
        version: '10.5.2',
        image: 'sheets.png',
        scale: 1,
        size: {
          w: 658,
          h: 314,
        },
      },
    });

    await images2style({
      src: srcDir,
      dest: destFile,
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(output).toContain('.assets-sprites-sheet-frame1');
    expect(output).toContain('0% 0% / 100% 100%');

    expect(output).toContain('.assets-sprites-sheets-avatar-bg-0');
    expect(output).toContain('0% 0% / 301.8349% 112.1429%');
    expect(output).toContain('.assets-sprites-sheets-avatar-bg-1');
    expect(output).toContain('50% 0% / 301.8349% 126.6129%');
    expect(output).toContain('.assets-sprites-sheets-avatar-bg-2');
    expect(output).toContain('100% 0% / 301.8349% 126.6129%');
    expect(output).toContain('.assets-sprites-sheets-fire');
    expect(output).toContain('69.8413% 87.4126% / 2350% 1121.4286%');
    expect(output).toContain('.assets-sprites-sheets-notice');
    expect(output).toContain('0% 100% / 2056.25% 981.25%');

    expect(output).not.toContain('NaN');
    expect(output).not.toContain('Infinity');
  });

  test('falls back to image style when atlas json is invalid', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();

    await writeFile(path.join(srcDir, 'bad.png'), Buffer.from('png'));
    await writeJson(path.join(srcDir, 'bad.json'), { foo: 'bar' });

    await images2style({
      src: srcDir,
      dest: destFile,
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(output).toContain('.assets-bad-png');
    expect(output).toContain('background-image:');
  });

  test('recursively collects nested images', async () => {
    const { srcDir, destFile } = await makeFixtureDirs();

    await writeFile(
      path.join(srcDir, 'icons', 'ui', 'play.svg'),
      Buffer.from('svg')
    );

    await images2style({
      src: srcDir,
      dest: destFile,
      silent: true,
    });

    const output = await fs.readFile(destFile, 'utf8');

    expect(output).toContain('.assets-icons-ui-play-svg');
  });
});
