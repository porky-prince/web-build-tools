import { FSWatcher, watch } from 'chokidar';
import path from 'path';
import webpack from 'webpack';
import fs from 'fs-extra';
import debounce from 'debounce';
import { isSafeFilename, toPercent } from 'web-build-utils';

type Plugin = webpack.WebpackPluginInstance;
type Compiler = webpack.Compiler;
// type Compilation = webpack.Compilation;
type Logger = ReturnType<Compiler['getInfrastructureLogger']>;

export interface Images2styleOptions {
  cwd?: string;
  src: string;
  dest: string;
  exclude?: (srcInfo: path.ParsedPath, src: string) => boolean;
  include?: (srcInfo: path.ParsedPath, src: string) => boolean;
  transform?: (
    content: string,
    srcInfo: path.ParsedPath,
    src: string
  ) => string;
  delay?: number;
  silent?: boolean;
}

const globalStyleTemplate = `/* This file was auto generated by images2style-webpack-plugin. */
.bg-full {
  background-size: 100% 100%;
}
{content}
`;

const imageStyleTemplate = `
.{className} {
  background-image: url('{imagePath}');
}
`;

const atlasStyleTemplate = `
.{className} {
  background: url('{imagePath}') {x}% {y}% / {w}% {h}% no-repeat;
}
`;

function toPercentStr(num: number): string {
  return toPercent(num, 4) + '';
}

export default class Images2styleWebpackPlugin implements Plugin {
  private _options: Required<Images2styleOptions>;
  private _watcher: FSWatcher | null = null;
  private _logger: Logger | null = null;

  constructor(options: Images2styleOptions) {
    if (path.extname(options.src)) {
      throw new Error('The options.src must be a directory.');
    }
    if (!path.extname(options.dest)) {
      throw new Error('The options.dest must be a file.');
    }

    this._options = {
      cwd: process.cwd(),
      exclude: () => false,
      include: () => true,
      transform: (content) => content,
      delay: 200,
      silent: true,
      ...options,
    };
  }

  private get pluginName() {
    return this.constructor.name;
  }

  private log(...args: any[]): void {
    if (!this._logger || this._options.silent) {
      return;
    }
    this._logger.log(...args);
  }

  private getWatcher(
    cb: (event: string, path: string, stats?: fs.Stats) => void
  ) {
    if (!this._watcher) {
      fs.ensureDirSync(this._options.src);
      this._watcher = watch('.', {
        cwd: this._options.src,
        ignoreInitial: true,
      });
      this._watcher.on('all', cb);
    }
    return this._watcher;
  }

  apply(compiler: Compiler) {
    this._logger = compiler.getInfrastructureLogger(this.pluginName);
    const { src, dest, delay } = this._options;
    const pack = async () => {
      const res = await this.pack(src);
      await fs.outputFile(
        dest,
        globalStyleTemplate.replace('{content}', res.code)
      );
    };
    const delayPack = debounce(pack, delay);

    compiler.hooks.run.tapPromise(this.pluginName, pack);

    let once = false;
    compiler.hooks.watchRun.tapPromise(this.pluginName, async () => {
      if (once) {
        return;
      }
      once = true;
      this.getWatcher((e, p) => {
        if (!isSafeFilename(p, true)) {
          return;
        }
        this.log(e, p);
        delayPack();
      });
      await pack();
    });
  }

  private async pack(src: string, res = { code: '' }) {
    this.log('pack', src);
    const { exclude, include } = this._options;
    const fullNames = await fs.readdir(src);
    await Promise.all(
      fullNames.map(async (fullName) => {
        const srcPath = path.join(src, fullName);
        const info = path.parse(srcPath);
        if (!isSafeFilename(srcPath, true) || exclude(info, srcPath)) {
          return;
        }
        if (info.ext) {
          // File
          if (
            /^\.(jpe?g|png|gif|svg|webp)$/i.test(info.ext) &&
            include(info, srcPath)
          ) {
            const code = await this.genStyle(info, srcPath);
            res.code += code;
          }
        } else {
          // Dir
          await this.pack(srcPath, res);
        }
      })
    );

    this.log('packed', src);
    return res;
  }

  private async genStyle(info: path.ParsedPath, srcPath: string) {
    const { cwd, src, transform } = this._options;
    const baseDir = path.dirname(src);
    const srcDir = path.dirname(srcPath);
    const className =
      path.relative(baseDir, srcDir).replace(/[\\/]+/g, '-') + '-' + info.name;
    const imagePath = `~/${path.relative(cwd, srcPath)}`;

    let content = '';
    const atlasPath = path.join(srcDir, info.name + '.json');
    if (fs.existsSync(atlasPath)) {
      const json = await fs.readJSON(atlasPath, { throws: false });
      if (json && json.meta && json.frames) {
        const { w: width, h: height } = json.meta.size;
        Object.keys(json.frames).forEach((name) => {
          const { x, y, w, h } = json.frames[name].frame;
          const diffW = width - w || 1;
          const diffH = height - h || 1;
          const percentX = toPercentStr(x / diffW);
          const percentY = toPercentStr(y / diffH);
          const percentW = toPercentStr(width / w);
          const percentH = toPercentStr(height / h);
          content += atlasStyleTemplate
            .replace('{className}', className + '-' + name)
            .replace('{imagePath}', imagePath)
            .replace('{x}', percentX)
            .replace('{y}', percentY)
            .replace('{w}', percentW)
            .replace('{h}', percentH);
        });
      } else if (json) {
        this.log('Unsupported atlas file:', atlasPath);
      }
    }

    if (!content) {
      content = imageStyleTemplate
        .replace('{className}', className + info.ext.replace('.', '-'))
        .replace('{imagePath}', imagePath);
    }

    return transform(content, info, srcPath);
  }
}
